<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>スマホ対応シューティング（仮想スティック / タップ開始&再開）</title>
<style>
  :root{
    --maxW: 420px;
  }
  body{
    margin:0;
    background:#000;
    color:#fff;
    font-family:sans-serif;
    touch-action:none;
    -webkit-user-select:none;
    user-select:none;
    overscroll-behavior:none;
  }

  /* 画面全体を縦に収める（UIが下に隠れない） */
  #wrap{
    height: 100dvh; /* iOS/Androidのアドレスバー変動対策 */
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start; /* 上詰め */
    padding-top: 6px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* iPhoneホームバー対策 */
    box-sizing:border-box;
    gap: 6px;
  }

  h3{
    margin: 4px 0 0;
    font-size: 18px;
  }

  /* キャンバス：画面高さに合わせて縮小して必ず見えるようにする */
  canvas{
    background:#111;
    display:block;
    width: min(var(--maxW), 100vw);
    height: auto; /* JSで高さを決めるのでOK */
    touch-action:none;
  }

  #controls{
    width: min(var(--maxW), 100vw);
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding: 6px 10px 0;
    box-sizing:border-box;
    gap:12px;
  }

  /* 仮想スティック */
  #stickArea{
    position:relative;
    width:120px;
    height:120px;
    border-radius:50%;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.18);
    overflow:hidden;
    touch-action:none;
    flex:0 0 auto;
  }
  #stickKnob{
    position:absolute;
    left:50%;
    top:50%;
    width:52px;
    height:52px;
    margin-left:-26px;
    margin-top:-26px;
    border-radius:50%;
    background:rgba(255,255,255,0.25);
    border:1px solid rgba(255,255,255,0.25);
    backdrop-filter: blur(2px);
    transform: translate(0,0);
  }

  #shotBtn{
    width:140px;
    height:64px;
    font-size:20px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.25);
    background:rgba(255,255,255,0.10);
    color:#fff;
    touch-action:none;
    flex:0 0 auto;
  }
  #shotBtn:active{ background:rgba(255,255,255,0.18); }

  #status{
    margin: 2px 0 0;
    font-size: 14px;
    width: min(var(--maxW), 100vw);
    text-align:center;
    opacity:0.95;
  }
</style>
</head>
<body>

<div id="wrap">
  <h3>シューティングゲーム</h3>
  <canvas id="game" width="400" height="600"></canvas>

  <div id="controls">
    <div id="stickArea" aria-label="仮想スティック">
      <div id="stickKnob"></div>
    </div>
    <button id="shotBtn">SHOT</button>
  </div>

  <p id="status"></p>
</div>

<script>
/* =========================
   レイアウト：画面に収まるよう canvas 高さを自動調整
   - UIが下に隠れないよう、残り高さでキャンバスを縮める
========================= */
const wrap = document.getElementById("wrap");
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const controls = document.getElementById("controls");
const statusText = document.getElementById("status");
const shotBtn = document.getElementById("shotBtn");
const stickArea = document.getElementById("stickArea");
const stickKnob = document.getElementById("stickKnob");

const BASE_W = 400;
const BASE_H = 600;

function fitCanvas(){
  // wrap内で「キャンバスに使える高さ」を計算
  const wrapRect = wrap.getBoundingClientRect();
  const controlsRect = controls.getBoundingClientRect();
  const statusRect = statusText.getBoundingClientRect();

  // タイトル(h3)はwrapのgap含めて大体吸収されるので、wrap内から残りを取る
  const used = (controlsRect.height + statusRect.height + 24); // 微調整の余白
  let availableH = wrapRect.height - used;

  // キャンバスの表示幅（CSSのwidthに合わせる）
  const displayW = Math.min(420, window.innerWidth);
  const scaleByW = displayW / BASE_W;

  // 高さが足りない場合は高さ基準で縮小
  let displayH = BASE_H * scaleByW;
  if (displayH > availableH){
    const scaleByH = availableH / BASE_H;
    displayH = BASE_H * scaleByH;
    canvas.style.width = (BASE_W * scaleByH) + "px";
  } else {
    canvas.style.width = displayW + "px";
  }
  canvas.style.height = displayH + "px";
}
window.addEventListener("resize", fitCanvas);
window.addEventListener("orientationchange", fitCanvas);

/* =========================
   ゲーム変数
========================= */
let score, lives, level, playerLevel;
let bullets, enemies;
let enemyTimer, gameOver;

let invincible, invincibleTimer, blinkTimer;

let boss = null;
const BOSS_HP = 30;
let player;

let isRunning = false;
let showStartText = true;

/* =========================
   入力（PC）
========================= */
const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

/* =========================
   仮想スティック
========================= */
let stickActive = false;
let stickPointerId = null;
let stickCenter = { x: 0, y: 0 };
let moveAxis = 0;
const STICK_MAX = 38;
const DEAD_ZONE = 0.10;

function updateStickCenter(){
  const r = stickArea.getBoundingClientRect();
  stickCenter.x = r.left + r.width / 2;
  stickCenter.y = r.top  + r.height / 2;
}
window.addEventListener("resize", updateStickCenter);
window.addEventListener("scroll", updateStickCenter, { passive:true });

function setKnob(dx, dy){ stickKnob.style.transform = `translate(${dx}px, ${dy}px)`; }
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

stickArea.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  stickActive = true;
  stickPointerId = e.pointerId;
  stickArea.setPointerCapture(stickPointerId);
  updateStickCenter();
  handleStickMove(e);
}, { passive:false });

stickArea.addEventListener("pointermove", (e) => {
  if (!stickActive || e.pointerId !== stickPointerId) return;
  e.preventDefault();
  handleStickMove(e);
}, { passive:false });

stickArea.addEventListener("pointerup", endStick, { passive:false });
stickArea.addEventListener("pointercancel", endStick, { passive:false });

function handleStickMove(e){
  const dxRaw = e.clientX - stickCenter.x;
  const dyRaw = e.clientY - stickCenter.y;
  const dist = Math.hypot(dxRaw, dyRaw);

  const ratio = dist > STICK_MAX ? (STICK_MAX / dist) : 1;
  const dx = dxRaw * ratio;
  const dy = dyRaw * ratio;

  setKnob(dx, dy);

  let ax = dx / STICK_MAX;
  if (Math.abs(ax) < DEAD_ZONE) ax = 0;
  moveAxis = clamp(ax, -1, 1);
}
function endStick(e){
  if (!stickActive) return;
  e.preventDefault();
  stickActive = false;
  stickPointerId = null;
  moveAxis = 0;
  setKnob(0, 0);
}

/* =========================
   ショット（長押し連射）
========================= */
let shotHeld = false;
let shotCooldown = 0;
const SHOT_INTERVAL = 8;

function fireOnce(){
  if (!isRunning) return;
  if (bullets.length >= 8) return;

  if (playerLevel >= 2) {
    bullets.push({x: player.x + 8,  y: player.y});
    bullets.push({x: player.x + 28, y: player.y});
  } else {
    bullets.push({x: player.x + 18, y: player.y});
  }
}

shotBtn.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  shotHeld = true;
  fireOnce();
}, { passive:false });

window.addEventListener("pointerup", () => { shotHeld = false; }, { passive:true });
window.addEventListener("pointercancel", () => { shotHeld = false; }, { passive:true });

function handleSpaceShot(){
  if (keys.Space) {
    fireOnce();
    keys.Space = false;
  }
}

/* =========================
   タップで開始 / リスタート
   - UI操作（スティック/SHOT）では発火しない
========================= */
function isTapOnControls(target){
  return target === shotBtn || stickArea.contains(target) || target === stickArea;
}
function startGame(){
  if (gameOver) return;
  isRunning = true;
  showStartText = false;
}
function restartGame(){
  init();
  isRunning = true;
  showStartText = false;
}
function handleScreenTap(e){
  if (isTapOnControls(e.target)) return;
  if (gameOver) restartGame();
  else if (!isRunning) startGame();
}
canvas.addEventListener("pointerdown", handleScreenTap, { passive:true });
document.body.addEventListener("pointerdown", handleScreenTap, { passive:true });

/* =========================
   ゲーム本体
========================= */
function init() {
  score = 0;
  lives = 3;
  level = 1;
  playerLevel = 1;

  bullets = [];
  enemies = [];
  enemyTimer = 0;

  gameOver = false;
  invincible = false;
  invincibleTimer = 0;
  blinkTimer = 0;

  boss = null;
  player = { x: 180, y: 520, w: 40, h: 40, speed: 5 };

  isRunning = false;
  showStartText = true;

  updateStatus();
  updateStickCenter();
  fitCanvas();
}

function updateStatus() {
  statusText.textContent =
    `Score:${score} 残機:${lives} LEVEL:${level} PLAYER LV:${playerLevel}`;
}

function hit(a, aw, ah, b){
  return a.x < b.x + b.w && a.x + aw > b.x &&
         a.y < b.y + b.h && a.y + ah > b.y;
}

function damage(){
  lives--;
  invincible = true;
  invincibleTimer = 80;
  blinkTimer = 0;
  if (lives <= 0){
    gameOver = true;
    isRunning = false;
  }
}

function update(){
  if (!isRunning || gameOver) return;

  if (invincible){
    invincibleTimer--;
    blinkTimer++;
    if (invincibleTimer <= 0){
      invincible = false;
      blinkTimer = 0;
    }
  }

  let vx = 0;
  if (keys.ArrowLeft) vx -= 1;
  if (keys.ArrowRight) vx += 1;
  if (moveAxis !== 0) vx = moveAxis;

  const speed = player.speed * Math.abs(vx);
  if (vx < 0 && player.x > 0) player.x -= speed;
  if (vx > 0 && player.x < BASE_W - player.w) player.x += speed;

  handleSpaceShot();

  if (shotHeld){
    if (shotCooldown <= 0){
      fireOnce();
      shotCooldown = SHOT_INTERVAL;
    } else shotCooldown--;
  } else shotCooldown = 0;

  bullets.forEach(b => b.y -= 7);
  bullets = bullets.filter(b => b.y > 0);

  if (!boss){
    enemyTimer++;
    if (enemyTimer > Math.max(15, 40 - level * 3)){
      enemies.push({
        x: Math.random() * 370,
        y: -25,
        w: 25, h: 25,
        speed: 2 + level * 0.5
      });
      enemyTimer = 0;
    }
  }

  enemies.forEach(e => e.y += e.speed);

  if (!boss && score > 0 && score % 50 === 0){
    boss = { x: 100, y: 60, w: 200, h: 60, hp: BOSS_HP };
    enemies = [];
  }

  for (let bi = bullets.length - 1; bi >= 0; bi--){
    const b = bullets[bi];

    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if (hit(b, 4, 10, e)){
        bullets.splice(bi, 1);
        enemies.splice(ei, 1);
        score++;
        if (score % 15 === 0){ level++; playerLevel++; }
        break;
      }
    }

    if (boss && bi < bullets.length){
      if (hit(b, 4, 10, boss)){
        bullets.splice(bi, 1);
        boss.hp--;
        if (boss.hp <= 0){
          boss = null;
          score++;
        }
      }
    }
  }

  if (!invincible){
    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if (hit(player, player.w, player.h, e)){
        enemies.splice(ei, 1);
        damage();
        break;
      }
    }
  }

  updateStatus();
}

function draw(){
  ctx.clearRect(0, 0, BASE_W, BASE_H);

  if (!invincible || blinkTimer % 10 < 5){
    ctx.fillStyle = "cyan";
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  ctx.fillStyle = "yellow";
  bullets.forEach(b => ctx.fillRect(b.x, b.y, 4, 10));

  ctx.fillStyle = "red";
  enemies.forEach(e => ctx.fillRect(e.x, e.y, e.w, e.h));

  if (boss){
    ctx.fillStyle = "purple";
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);

    const barWidth = 300, barHeight = 10, barX = 50, barY = 20;
    ctx.fillStyle = "gray";
    ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = "lime";
    ctx.fillRect(barX, barY, barWidth * (boss.hp / BOSS_HP), barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(barX, barY, barWidth, barHeight);
  }

  if (showStartText && !gameOver){
    ctx.fillStyle = "white";
    ctx.font = "22px sans-serif";
    ctx.fillText("画面をタップしてスタート", 60, 310);
    ctx.font = "14px sans-serif";
    ctx.fillText("左：スティック / 右：SHOT", 112, 338);
  }

  if (gameOver){
    ctx.fillStyle = "white";
    ctx.font = "30px sans-serif";
    ctx.fillText("GAME OVER", 100, 285);
    ctx.font = "18px sans-serif";
    ctx.fillText("画面をタップでリスタート", 70, 325);
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

// iOS対策：ダブルタップズーム抑制
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
  const now = (new Date()).getTime();
  if (now - lastTouchEnd <= 300) event.preventDefault();
  lastTouchEnd = now;
}, { passive:false });

init();
loop();
</script>
</body>
</html>
