<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>スマホ対応シューティング（仮想スティック / タップ開始&再開）</title>
<style>
  body{
    margin:0;
    background:#000;
    color:#fff;
    text-align:center;
    font-family:sans-serif;
    touch-action:none;
    -webkit-user-select:none;
    user-select:none;
    overscroll-behavior:none;
  }
  h3{ margin:10px 0 6px; }
  canvas{
    background:#111;
    display:block;
    margin:0 auto;
    touch-action:none;
  }
  #status{ margin:8px 0 6px; }

  #controls{
    width:400px;
    margin:0 auto;
    display:flex;
    justify-content:space-between;
    align-items:center;
    padding:8px 10px 14px;
    box-sizing:border-box;
    gap:12px;
  }

  /* 仮想スティック */
  #stickArea{
    position:relative;
    width:140px;
    height:140px;
    border-radius:50%;
    background:rgba(255,255,255,0.08);
    border:1px solid rgba(255,255,255,0.18);
    overflow:hidden;
    touch-action:none;
  }
  #stickKnob{
    position:absolute;
    left:50%;
    top:50%;
    width:56px;
    height:56px;
    margin-left:-28px;
    margin-top:-28px;
    border-radius:50%;
    background:rgba(255,255,255,0.25);
    border:1px solid rgba(255,255,255,0.25);
    backdrop-filter: blur(2px);
    transform: translate(0,0);
  }

  #shotBtn{
    width:140px;
    height:70px;
    font-size:22px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,0.25);
    background:rgba(255,255,255,0.10);
    color:#fff;
    touch-action:none;
  }
  #shotBtn:active{ background:rgba(255,255,255,0.18); }

  /* 狭い画面 */
  @media (max-width: 420px){
    canvas{ width: 100vw; height:auto; }
    #controls{ width:100vw; }
    #stickArea{ width:120px; height:120px; }
    #shotBtn{ width:120px; height:64px; font-size:20px; }
  }
</style>
</head>
<body>

<h3>シューティングゲーム</h3>
<canvas id="game" width="400" height="600"></canvas>

<div id="controls">
  <div id="stickArea" aria-label="仮想スティック">
    <div id="stickKnob"></div>
  </div>
  <button id="shotBtn">SHOT</button>
</div>

<p id="status"></p>

<script>
/* =========================
   基本セット
========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const statusText = document.getElementById("status");
const shotBtn = document.getElementById("shotBtn");
const stickArea = document.getElementById("stickArea");
const stickKnob = document.getElementById("stickKnob");

let score, lives, level, playerLevel;
let bullets, enemies;
let enemyTimer, gameOver;

let invincible, invincibleTimer, blinkTimer;

let boss = null;
const BOSS_HP = 30;
let player;

/* 追加：スタート待ち */
let isRunning = false;     // false=スタート待ち（停止）, true=ゲーム進行
let showStartText = true;  // 文字表示制御

/* =========================
   入力（PCキーボード）
========================= */
const keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

/* =========================
   仮想スティック（Pointer Events）
========================= */
let stickActive = false;
let stickPointerId = null;
let stickCenter = { x: 0, y: 0 };
let moveAxis = 0;        // -1（左）〜 +1（右）
const STICK_MAX = 42;    // ノブ最大半径(px)
const DEAD_ZONE = 0.10;  // 遊び

function updateStickCenter(){
  const r = stickArea.getBoundingClientRect();
  stickCenter.x = r.left + r.width / 2;
  stickCenter.y = r.top  + r.height / 2;
}
window.addEventListener("resize", updateStickCenter);
window.addEventListener("scroll", updateStickCenter, { passive:true });

function setKnob(dx, dy){
  stickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
}
function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

stickArea.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  stickActive = true;
  stickPointerId = e.pointerId;
  stickArea.setPointerCapture(stickPointerId);
  updateStickCenter();
  handleStickMove(e);
}, { passive:false });

stickArea.addEventListener("pointermove", (e) => {
  if (!stickActive || e.pointerId !== stickPointerId) return;
  e.preventDefault();
  handleStickMove(e);
}, { passive:false });

stickArea.addEventListener("pointerup", endStick, { passive:false });
stickArea.addEventListener("pointercancel", endStick, { passive:false });

function handleStickMove(e){
  const dxRaw = e.clientX - stickCenter.x;
  const dyRaw = e.clientY - stickCenter.y;
  const dist = Math.hypot(dxRaw, dyRaw);

  const ratio = dist > STICK_MAX ? (STICK_MAX / dist) : 1;
  const dx = dxRaw * ratio;
  const dy = dyRaw * ratio;

  setKnob(dx, dy);

  let ax = dx / STICK_MAX;
  if (Math.abs(ax) < DEAD_ZONE) ax = 0;
  moveAxis = clamp(ax, -1, 1);
}
function endStick(e){
  if (!stickActive) return;
  e.preventDefault();
  stickActive = false;
  stickPointerId = null;
  moveAxis = 0;
  setKnob(0, 0);
}

/* =========================
   ショット（長押し連射対応）
========================= */
let shotHeld = false;
let shotCooldown = 0;
const SHOT_INTERVAL = 8;

function fireOnce(){
  if (!isRunning) return;          // ★スタート前は撃てない
  if (bullets.length >= 8) return;

  if (playerLevel >= 2) {
    bullets.push({x: player.x + 8,  y: player.y});
    bullets.push({x: player.x + 28, y: player.y});
  } else {
    bullets.push({x: player.x + 18, y: player.y});
  }
}

shotBtn.addEventListener("pointerdown", (e) => {
  e.preventDefault();
  shotHeld = true;
  fireOnce();
}, { passive:false });

window.addEventListener("pointerup", () => { shotHeld = false; }, { passive:true });
window.addEventListener("pointercancel", () => { shotHeld = false; }, { passive:true });

function handleSpaceShot(){
  if (keys.Space) {
    fireOnce();
    keys.Space = false;
  }
}

/* =========================
   タップでスタート / リスタート
   - 画面どこでもタップでOK
   - ただしスティックやSHOT操作のタップは除外
========================= */
function startGame(){
  if (gameOver) return;
  isRunning = true;
  showStartText = false;
}

function restartGame(){
  init();
  isRunning = true;
  showStartText = false;
}

function isTapOnControls(target){
  return target === shotBtn || stickArea.contains(target) || target === stickArea;
}

function handleScreenTap(e){
  // UI（スティック/ボタン）操作はゲーム開始トリガーにしない
  if (isTapOnControls(e.target)) return;

  if (gameOver) {
    restartGame();
  } else if (!isRunning) {
    startGame();
  }
}

canvas.addEventListener("pointerdown", (e) => {
  // キャンバスをタップ → 開始/再開（ただしスティック操作と被らない）
  handleScreenTap(e);
}, { passive:true });

// 念のため body 全体でも拾う（見出し・余白タップ対応）
document.body.addEventListener("pointerdown", (e) => {
  handleScreenTap(e);
}, { passive:true });

/* =========================
   ゲーム本体
========================= */
function init() {
  score = 0;
  lives = 3;
  level = 1;
  playerLevel = 1;

  bullets = [];
  enemies = [];

  enemyTimer = 0;
  gameOver = false;

  invincible = false;
  invincibleTimer = 0;
  blinkTimer = 0;

  boss = null;

  player = { x: 180, y: 520, w: 40, h: 40, speed: 5 };

  // ★初期はスタート待ち
  isRunning = false;
  showStartText = true;

  updateStickCenter();
  updateStatus();
}

function updateStatus() {
  statusText.textContent =
    `Score:${score} 残機:${lives} LEVEL:${level} PLAYER LV:${playerLevel}`;
}

function hit(a, aw, ah, b){
  return a.x < b.x + b.w && a.x + aw > b.x &&
         a.y < b.y + b.h && a.y + ah > b.y;
}

function damage(){
  lives--;
  invincible = true;
  invincibleTimer = 80;
  blinkTimer = 0;
  if (lives <= 0){
    gameOver = true;
    isRunning = false;       // ★ゲーム停止
  }
}

function update(){
  if (!isRunning) return; // ★スタート待ち or ゲームオーバー中は止める
  if (gameOver) return;

  // 無敵
  if (invincible){
    invincibleTimer--;
    blinkTimer++;
    if (invincibleTimer <= 0){
      invincible = false;
      blinkTimer = 0;
    }
  }

  // 移動：キーボード or スティック
  let vx = 0;
  if (keys.ArrowLeft) vx -= 1;
  if (keys.ArrowRight) vx += 1;
  if (moveAxis !== 0) vx = moveAxis;

  const speed = player.speed * Math.abs(vx);
  if (vx < 0 && player.x > 0) player.x -= speed;
  if (vx > 0 && player.x < canvas.width - player.w) player.x += speed;

  // 発射
  handleSpaceShot();

  // 長押し連射
  if (shotHeld){
    if (shotCooldown <= 0){
      fireOnce();
      shotCooldown = SHOT_INTERVAL;
    } else {
      shotCooldown--;
    }
  } else {
    shotCooldown = 0;
  }

  // 弾
  bullets.forEach(b => b.y -= 7);
  bullets = bullets.filter(b => b.y > 0);

  // 敵生成
  if (!boss){
    enemyTimer++;
    if (enemyTimer > Math.max(15, 40 - level * 3)){
      enemies.push({
        x: Math.random() * 370,
        y: -25,
        w: 25, h: 25,
        speed: 2 + level * 0.5
      });
      enemyTimer = 0;
    }
  }

  // 敵移動
  enemies.forEach(e => e.y += e.speed);

  // ボス出現（50点ごと）
  if (!boss && score > 0 && score % 50 === 0){
    boss = { x: 100, y: 60, w: 200, h: 60, hp: BOSS_HP };
    enemies = [];
  }

  // 弾ヒット
  for (let bi = bullets.length - 1; bi >= 0; bi--){
    const b = bullets[bi];

    // 通常敵
    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if (hit(b, 4, 10, e)){
        bullets.splice(bi, 1);
        enemies.splice(ei, 1);
        score++;
        if (score % 15 === 0){ level++; playerLevel++; }
        break;
      }
    }

    // ボス
    if (boss && bi < bullets.length){
      if (hit(b, 4, 10, boss)){
        bullets.splice(bi, 1);
        boss.hp--;
        if (boss.hp <= 0){
          boss = null;
          score++;
        }
      }
    }
  }

  // 被弾
  if (!invincible){
    for (let ei = enemies.length - 1; ei >= 0; ei--){
      const e = enemies[ei];
      if (hit(player, player.w, player.h, e)){
        enemies.splice(ei, 1);
        damage();
        break;
      }
    }
  }

  updateStatus();
}

function draw(){
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 自機
  if (!invincible || blinkTimer % 10 < 5){
    ctx.fillStyle = "cyan";
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  // 弾
  ctx.fillStyle = "yellow";
  bullets.forEach(b => ctx.fillRect(b.x, b.y, 4, 10));

  // 敵
  ctx.fillStyle = "red";
  enemies.forEach(e => ctx.fillRect(e.x, e.y, e.w, e.h));

  // ボス + HPバー
  if (boss){
    ctx.fillStyle = "purple";
    ctx.fillRect(boss.x, boss.y, boss.w, boss.h);

    const barWidth = 300, barHeight = 10, barX = 50, barY = 20;
    ctx.fillStyle = "gray";
    ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.fillStyle = "lime";
    ctx.fillRect(barX, barY, barWidth * (boss.hp / BOSS_HP), barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(barX, barY, barWidth, barHeight);
  }

  // ★開始案内
  if (showStartText && !gameOver){
    ctx.fillStyle = "white";
    ctx.font = "22px sans-serif";
    ctx.fillText("画面をタップしてスタート", 60, 310);
    ctx.font = "14px sans-serif";
    ctx.fillText("左：スティック / 右：SHOT", 112, 338);
  }

  // ★ゲームオーバー案内
  if (gameOver){
    ctx.fillStyle = "white";
    ctx.font = "30px sans-serif";
    ctx.fillText("GAME OVER", 100, 285);
    ctx.font = "18px sans-serif";
    ctx.fillText("画面をタップでリスタート", 70, 325);
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

// iOS対策：ダブルタップズーム抑制
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
  const now = (new Date()).getTime();
  if (now - lastTouchEnd <= 300) event.preventDefault();
  lastTouchEnd = now;
}, { passive:false });

init();
loop();
</script>
</body>
</html>
